__global__ void LGN_maxResponse(_float* __restrict__ max_convol,
                                LGN_parameter pLGN, // consider pointer
                                unsigned int nKernelSample, _float kernelSampleDt, unsigned int nsig, unsigned int npixel_1D) {

    __shared__ _float linearResponse[warpSize];
    extern __shared__ _float temporalWeight[];
    Float convol;

    // consider store LGN_subregion, facRatio to __shared__

    unsigned int id = blockIdx.x;

    // load
    LGN_subregion center(pLGN.center, id);
    LGN_subregion surround(pLGN.surround, id);
    
    unsigned int tid = threadIdx.y*blockDim.x + threadIdx.x;
    _float covariant = pLGN.covariant[id];
    _float sqrt2 = square_root(2.0);
    if (tid == 0) {
        convol = 0.0f;
    }

    // load temporal weights
    unsigned int block_size = blockDim.x*blockDim.y;
    unsigned int nblock = nKernelSample/block_size;

    for (unsigned int iblock = 0; iblock < nblock; iblock++) {
        unsigned int twid = iblock*block_size + tid;
        _float t = (twid + 1)*kernelSampleDt;
        temporalWeight[twid] = temporalKernel(t, center);
        temporalWeight[nKernelSample + twid] = temporalKernel(t, surround);
    }
    
    if (tid < nKernelSample - nblock*block_size) {
        unsigned int twid = nblock*block_size + tid;
        _float t = (twid + 1)*kernelSampleDt;
        temporalWeight[twid] = temporalKernel(t, center);
        temporalWeight[nKernelSample + twid] = temporalKernel(t, surround);
    }
    __syncthreads();

    _float signCS = copy(1.0, center.k * surround.k);
    // pair spatial kernel
        // center
    _float xhspan = nsig * center.rx / sqrt2;
    _float dx = 2*xhspan/npixel_1D;

    _float yhspan = nsig * center.ry / sqrt2;
    _float dy = 2*yhspan/npixel_1D;

    _float x = threadIdx.x*dx - xhspan;
    _float y = threadIdx.y*dy - yhspan;

    _float x_prime = center.x + x - surround.x;
    _float y_prime = center.y + y - surround.y;

    _float sample_vol = dx * dy * kernelSampleDt;

    _float spatialWeightC = spatialKernel(x, y, 1.0, center.k, center.rx, center.ry);
    _float spatialWeightS = spatialKernel(x_prime, y_prime, 1.0, surround.k, surround.rx, surround.ry);
    
    for (unsigned int it=0; it<nKernelSample; it++) {
        Float filter = abs(spatialWeightC * temporalWeight[it]);
        Float filter_prime = abs(spatialWeightS * temporalWeight[nKernelSample + it]);

        if (filter < filter_prime) {
            filter *= copy(covariant, signCS);
        } 

        block_reduce<Float>(linearResponse, filter);

        if (tid == 0) { // acquire spatial filtered input
            convol += linearResponse[0]*sample_vol;
        }
    }
    
        // surround
    xhspan = nsig * surround.rx / sqrt2;
    dx = 2*xhspan/npixel_1D;

    yhspan = nsig * surround.ry / sqrt2;
    dy = 2*yhspan/npixel_1D;

    x = threadIdx.x*dx - xhspan;
    y = threadIdx.y*dy - yhspan;

    x_prime = surround.x + x - center.x;
    y_prime = surround.y + y - center.y;

    sample_vol = dx * dy * kernelSampleDt;
    spatialWeightS = spatialKernel(x, y, 1.0, surround.k, surround.rx, surround.ry);
    spatialWeightC = spatialKernel(x_prime, y_prime, 1.0, center.k, center.rx, center.ry);
    
    for (unsigned int it=0; it<nKernelSample; it++) {

        _float filter = abs(spatialWeightS * temporalWeight[nKernelSample + it]);
        _float filter_prime = abs(spatialWeightC * temporalWeight[it]);

        if (filter < filter_prime) {
            filter *= copy(covariant, signCS);
        }

        block_reduce<Float>(linearResponse, filter);

        if (tid == 0) { // acquire spatial filtered input
            convol += linearResponse[0]*sample_vol; 
        }
    }

    // output
    if (tid == 0) {
        assert(convol >= 0);
        max_convol[blockIdx.x] = convol;
    }
}

/* functions not in use:
    __device__
    __inline__
    void plane_to_retina(float x0, float y0, Float &x, Float &y) {
        Float r = sqrt(x0*x0 + y0*y0);
        Float atanr = -atan(r);
        Float xr = x0/r;
        Float yr = x0/r;
        x = xr*atanr;
        y = yr*atanr;
    }
*/
/*
Per frame
    max spatial sample size: 32 x 32
    number of temporal kernel evaluation <= spatial sample size
*/
// grid: nLGN blocks
// block: spatialSample1D x spatialSample1D (npixel_1D)
__global__ void LGN_convol(_float* __restrict__ LGNfr,
                           LGN_parameter pLGN, // consider pointer
                           unsigned int iSample0,
                           _float samplePhase, unsigned int nKernelSample, _float kernelSampleDt, unsigned int nsig, unsigned int npixel_1D) {

    __shared__ _float linearResponse[warpSize];
    extern __shared__ _float temporalWeight[];
    Float convol;

    // consider store LGN_subregion, facRatio to __shared__

    unsigned int id = blockIdx.x;

    // load
    LGN_subregion center(pLGN.center, id);
    LGN_subregion surround(pLGN.surround, id);

    _float sqrt2 = square_root(2.0);
    unsigned int tid = threadIdx.y*blockDim.x + threadIdx.x;
    if (tid == 0) {
        convol = 0.0f;
    }
        /*
         
       framePhase                    tPerFrame - framePhase
time     | ^ |-------> tPerFrame <------|      ^      |
frame: prev curr                   next
sample:  1        2        3        4        5        6
         |...:----|--------|--------|---:----|--------|
dt:      0   3    8        16       24       32       40
tau = 40*dt
          
        */

    // load temporal weights using all the threads in the block
    unsigned int block_size = blockDim.x*blockDim.y;
    unsigned int nblock = nKernelSample/block_size;

    for (unsigned int iblock = 0; iblock < nblock; iblock++) {
        unsigned int twid = iblock*block_size + tid;
        _float t = twid*kernelSampleDt + samplePhase;
        temporalWeight[twid] = temporalKernel(t, center);
        temporalWeight[nKernelSample + twid] = temporalKernel(t, surround);
    }
    
    if (tid < nKernelSample - nblock*block_size) {
        unsigned int twid = nblock*block_size + tid;
        _float t = twid*kernelSampleDt + samplePhase;
        temporalWeight[twid] = temporalKernel(t, center);
        temporalWeight[nKernelSample + twid] = temporalKernel(t, surround);
    }
    __syncthreads();

    // calculate spatial filter
        // center
    unsigned int type = pLGN.centerType[id];

    _float xhspan = nsig * center.rx / sqrt2;
    _float dx = 2*xhspan/npixel_1D;

    _float yhspan = nsig * center.ry / sqrt2;
    _float dy = 2*yhspan/npixel_1D;

    _float x = threadIdx.x*dx - xhspan;
    _float y = threadIdx.y*dy - yhspan;
    float x0 = static_cast<float>(center.x + x);
    float y0 = static_cast<float>(center.y + y);

    _float sample_vol = dx * dy;
    _float spatialWeight = spatialKernel(x, y, 1.0f, center.k, center.rx, center.ry);
    
    Float decay = expp(-samplePhase/tau_ave);
    unsigned int it = 0;
    Float old_qs = q[id]; // sum_i(F_i[exp(-t_i+1/tau) - exp(-t_i/tau)])*exp(-t/tau)
    for (unsigned int iSample=iSample0; iSample<iSample0+nKernelSample; iSample++) {
        unsigned int jSample = iSample % nKernelSample;

        retina_to_plane(x, y, x0, y0);
        Float local_I = get_intensity(type, x, y, jSample);
        block_reduce<Float>(linearResponse, local_I);
        if (tid == 0) {
            old_qs
            Float this_q = linearResponse[0];
            Float sum_I = linearResponse[0]*(1-decay);
            sum_I += old_qs*decay + ;
            if samplePhase
            old_I = old_I + expp(
        }
        __device__
        __inline__
        Float next_I

        Float filtered = spatialWeight * get_intensity(type, x0, y0, jSample);

        block_reduce<Float>(linearResponse, filtered);

        if (tid == 0) {
            filtered = linearResponse[0];
            if (it == 0) {
                filtered *= kernelSampleDt - samplePhase;
            } else {
                if (it == nKernelSample-1) {
                    filtered *= samplePhase;
                } else {
                    filtered *= kernelSampleDt;
                }
            }
            convol += filtered*temporalWeight[nKernelSample-1-it]*sample_vol; 
            it++;
        }
    }

        // surround
    type = pLGN.surroundType[id];

    xhspan = nsig * surround.rx / sqrt2;
    dx = 2*xhspan/npixel_1D;

    yhspan = nsig * surround.ry / sqrt2;
    dy = 2*yhspan/npixel_1D;

    x = threadIdx.x*dx - xhspan;
    y = threadIdx.y*dy - yhspan;
    x0 = static_cast<float>(surround.x + x);
    y0 = static_cast<float>(surround.y + y);

    sample_vol = dx * dy;
    spatialWeight = spatialKernel(x, y, 1.0f, surround.k, surround.rx, surround.ry);
    
    it = 0;
    for (unsigned int iSample=iSample0+nKernelSample; iSample>iSample0; iSample--) {
        unsigned int jSample = iSample % nKernelSample;
        Float filtered = spatialWeight * get_intensity(type, x0, y0, jSample);

        block_reduce<Float>(linearResponse, filtered);
         
        if (tid == 0) { // acquire spatial filtered input
            filtered = linearResponse[0];
            if (it == 0) {
                filtered *= samplePhase;
            } else {
                if (it == nKernelSample-1) {
                    filtered *= kernelSampleDt - samplePhase;
                } else {
                    filtered *= kernelSampleDt;
                }
            }
            convol += filtered*temporalWeight[nKernelSample + it]*sample_vol; 
        }
        it++;
    }

    // output
    if (tid == 0) {
        LGNfr[blockIdx.x] = convol;
    }
}
